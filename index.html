<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shibarium Serge NFT Merger</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; }
        button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #45a049; }
        #status { margin-top: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <h1>Shibarium Serge NFT Merger</h1>
    <p>Enter one private key per line (with "0x" prefix):</p>
    <textarea id="privateKeys" placeholder="e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"></textarea>
    <button onclick="mergeNFTs()">Merge NFTs</button>
    <div id="status">Status: Ready</div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        const SHIBARIUM_RPC = "https://rpc.shibarium.io";
        const CONTRACT_ADDRESS = "0x9FcEa3627746aEA84c8Eba612E1fD25aC27d605A";

        const CONTRACT_ABI = [
            {"constant": false, "inputs": [{"name": "tokenId1", "type": "uint256"}, {"name": "tokenId2", "type": "uint256"}], "name": "merge", "outputs": [], "type": "function"},
            {"constant": true, "inputs": [{"name": "owner_", "type": "address"}], "name": "tokensOfOwner", "outputs": [{"name": "", "type": "uint256[]"}], "type": "function"}
        ];

        const web3 = new Web3(new Web3.providers.HttpProvider(SHIBARIUM_RPC));
        const contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);

        async function mergeNFTs() {
            const status = document.getElementById("status");
            status.textContent = "Status: Starting...\n";

            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += "Error: No private keys provided.\n";
                return;
            }

            try {
                const walletPromises = privateKeys.map(async pk => {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    const tokens = await contract.methods.tokensOfOwner(account.address).call();
                    return { address: account.address, tokens };
                });

                const wallets = await Promise.all(walletPromises);
                let allTokenIds = [];
                wallets.forEach(w => {
                    status.textContent += `Wallet ${w.address} has ${w.tokens.length} NFTs: ${w.tokens.join(", ")}\n`;
                    allTokenIds.push(...w.tokens.map(t => ({ tokenId: t, owner: w.address })));
                });

                if (allTokenIds.length < 2) {
                    status.textContent += "Error: Need at least 2 NFTs to merge.\n";
                    return;
                }

                while (allTokenIds.length > 1) {
                    const tokensByOwner = {};
                    allTokenIds.forEach(token => {
                        if (!tokensByOwner[token.owner]) tokensByOwner[token.owner] = [];
                        tokensByOwner[token.owner].push(token.tokenId);
                    });

                    let mergeOwner = null;
                    let tokensToMerge = [];
                    for (const [owner, tokens] of Object.entries(tokensByOwner)) {
                        if (tokens.length >= 2) {
                            mergeOwner = owner;
                            tokensToMerge = tokens;
                            break;
                        }
                    }

                    if (!mergeOwner) {
                        status.textContent += "Error: No single wallet has 2+ NFTs to merge.\n";
                        return;
                    }

                    const tokenId1 = tokensToMerge[0];
                    const tokenId2 = tokensToMerge[1];
                    status.textContent += `Merging ${tokenId1} and ${tokenId2} from ${mergeOwner}...\n`;

                    const tx = await contract.methods.merge(tokenId1, tokenId2).send({ from: mergeOwner });
                    status.textContent += `Merge successful! Tx: ${tx.transactionHash}\nNew token ID: ${tx.events.NewNFTMinted.returnValues.tokenId}\n`;

                    allTokenIds = allTokenIds.filter(t => t.tokenId !== tokenId1 && t.tokenId !== tokenId2);
                    allTokenIds.push({
                        tokenId: tx.events.NewNFTMinted.returnValues.tokenId,
                        owner: mergeOwner
                    });
                }

                status.textContent += `Final NFT: ${allTokenIds[0].tokenId} owned by ${allTokenIds[0].owner}\nDone!\n`;
            } catch (error) {
                status.textContent += `Error: ${error.message}\n`;
            }
        }
    </script>
</body>
</html>
