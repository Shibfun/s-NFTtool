<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shibarium Serge NFT Merger</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; }
        button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #45a049; }
        #status { margin-top: 10px; white-space: pre-wrap; }
        .settings { margin: 10px 0; }
        .settings label { display: block; margin-bottom: 5px; }
        .settings input { width: 200px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Shibarium Serge NFT Merger</h1>
    <div class="settings">
        <label>Shibarium RPC URL: <input type="text" id="rpcUrl" value="https://www.shibrpc.com"></label>
        <label>Chain ID: <input type="text" id="chainId" value="109" readonly></label>
        <label>Network Name: <input type="text" id="networkName" value="Shibarium" readonly></label>
        <label>Currency Symbol: <input type="text" id="currencySymbol" value="BONE" readonly></label>
        <label>Block Explorer: <input type="text" id="blockExplorer" value="https://www.shibariumscan.io" readonly></label>
    </div>
    <p>Enter one private key per line (with "0x" prefix):</p>
    <textarea id="privateKeys" placeholder="e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"></textarea>
    <div class="settings">
        <label>Gas Price (Gwei): <input type="number" id="gasPrice" value="3.2" step="0.1" min="0"></label>
        <label>Gas Limit: <input type="number" id="gasLimit" value="300000" min="21000"></label>
        <label>Merge Interval (seconds): <input type="number" id="mergeInterval" value="5" min="1"></label>
    </div>
    <button onclick="mergeNFTs()">Merge NFTs</button>
    <div id="status">Status: Ready</div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        const CONTRACT_ADDRESS = "0x9FcEa3627746aEA84c8Eba612E1fD25aC27d605A";
        const MAX_MASS = 100000;

        const CONTRACT_ABI = [
            {"constant": false, "inputs": [{"name": "tokenId1", "type": "uint256"}, {"name": "tokenId2", "type": "uint256"}], "name": "merge", "outputs": [], "type": "function"},
            {"constant": true, "inputs": [{"name": "tokenId", "type": "uint256"}], "name": "massOf", "outputs": [{"name": "", "type": "uint256"}], "type": "function"},
            {"constant": true, "inputs": [{"name": "owner_", "type": "address"}], "name": "tokensOfOwner", "outputs": [{"name": "", "type": "uint256[]"}], "type": "function"}
        ];

        async function mergeNFTs() {
            const status = document.getElementById("status");
            status.textContent = "Status: Starting...\n";

            const rpcUrl = document.getElementById("rpcUrl").value.trim();
            const chainId = parseInt(document.getElementById("chainId").value);
            const expectedChainId = 109;

            if (!rpcUrl) {
                status.textContent += "Error: Please provide a valid Shibarium RPC URL.\n";
                return;
            }

            const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
            const contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);

            try {
                status.textContent += "Testing RPC connection...\n";
                const networkChainId = await web3.eth.getChainId();
                status.textContent += `Connected to chain ID: ${networkChainId} (Shibarium should be ${expectedChainId})\n`;
                if (networkChainId !== expectedChainId) {
                    status.textContent += `Error: Not connected to Shibarium network (chain ID should be ${expectedChainId}).\n`;
                    return;
                }
            } catch (error) {
                status.textContent += `Error: Failed to connect to RPC: ${error.message}\n`;
                return;
            }

            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += "Error: No private keys provided.\n";
                return;
            }

            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const mergeInterval = parseInt(document.getElementById("mergeInterval").value) * 1000;

            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += "Error: Invalid Gas Price.\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += "Error: Invalid Gas Limit (minimum 21000).\n";
                return;
            }
            if (isNaN(mergeInterval) || mergeInterval < 1000) {
                status.textContent += "Error: Invalid Merge Interval (minimum 1 second).\n";
                return;
            }

            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");

            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    const balance = await web3.eth.getBalance(account.address);
                    const balanceInBONE = web3.utils.fromWei(balance, "ether");
                    const tokens = await contract.methods.tokensOfOwner(account.address).call();
                    status.textContent += `Processing wallet ${account.address} with ${tokens.length} NFTs\n`;
                    if (balanceInBONE < 0.01) {
                        status.textContent += `Warning: Wallet ${account.address} has low BONE balance (${balanceInBONE}), may not cover Gas fees.\n`;
                    }

                    let allTokenIds = tokens.map(t => ({ tokenId: t, owner: account.address }));
                    if (allTokenIds.length < 2) {
                        status.textContent += `Wallet ${account.address} has less than 2 NFTs, skipping merge.\n`;
                        continue;
                    }

                    while (allTokenIds.length > 1) {
                        const shuffled = allTokenIds.sort(() => Math.random() - 0.5);
                        const tokenId1 = shuffled[0].tokenId;
                        const tokenId2 = shuffled[1].tokenId;

                        status.textContent += `Merging ${tokenId1} and ${tokenId2} from ${account.address}...\n`;

                        const mass1 = await contract.methods.massOf(tokenId1).call();
                        const mass2 = await contract.methods.massOf(tokenId2).call();
                        const newMass = parseInt(mass1) + parseInt(mass2);
                        if (newMass > MAX_MASS) {
                            status.textContent += `Error: Merging ${tokenId1} and ${tokenId2} would exceed MAX_MASS (${MAX_MASS}).\n`;
                            allTokenIds = allTokenIds.filter(t => t.tokenId !== tokenId2);
                            await new Promise(resolve => setTimeout(resolve, mergeInterval));
                            continue;
                        }

                        try {
                            const tx = await contract.methods.merge(tokenId1, tokenId2).send({
                                from: account.address,
                                gas: gasLimit,
                                gasPrice: gasPriceWei
                            });
                            const newTokenId = tx.events?.NewNFTMinted?.returnValues?.tokenId;
                            if (!newTokenId) {
                                const latestToken = await contract.methods.tokensOfOwner(account.address).call();
                                const lastToken = latestToken[latestToken.length - 1];
                                status.textContent += `New token ID not found in event, using latest: ${lastToken}\n`;
                                allTokenIds.push({ tokenId: lastToken, owner: account.address });
                            } else {
                                status.textContent += `Merge successful! Tx: ${tx.transactionHash}\nNew token ID: ${newTokenId}\n`;
                                allTokenIds.push({ tokenId: newTokenId, owner: account.address });
                            }
                            allTokenIds = allTokenIds.filter(t => t.tokenId !== tokenId1 && t.tokenId !== tokenId2);
                            await new Promise(resolve => setTimeout(resolve, mergeInterval));
                        } catch (mergeError) {
                            status.textContent += `Error merging ${tokenId1} and ${tokenId2}: ${mergeError.message}\n`;
                            allTokenIds = allTokenIds.filter(t => t.tokenId !== tokenId2);
                            await new Promise(resolve => setTimeout(resolve, mergeInterval));
                            continue;
                        }
                    }

                    const blockExplorer = document.getElementById("blockExplorer").value;
                    status.textContent += `Final NFT for ${account.address}: ${allTokenIds[0].tokenId}\n`;
                    status.textContent += `View on Shibariumscan: ${blockExplorer}/token/${CONTRACT_ADDRESS}/instance/${allTokenIds[0].tokenId}\n`;
                }
                status.textContent += "All wallets processed. Done!\n";
            } catch (error) {
                status.textContent += `Error: ${error.message}\n`;
            }
        }
    </script>
</body>
</html>
